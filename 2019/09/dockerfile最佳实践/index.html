<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.58.3 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="Eleven">
<meta name="keywords" content="">
<meta name="description" content="Docker通过读取Dockerfile中的指令自动构建镜像，一个文本文件包含构建镜像的所有指令。Dockerfile遵循特定的格式和指令集，您可以在Dockerfile中引用它们。">


<meta property="og:description" content="Docker通过读取Dockerfile中的指令自动构建镜像，一个文本文件包含构建镜像的所有指令。Dockerfile遵循特定的格式和指令集，您可以在Dockerfile中引用它们。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile最佳实践">
<meta name="twitter:title" content="Dockerfile最佳实践">
<meta property="og:url" content="https://veh47.github.io/2019/09/dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
<meta property="twitter:url" content="https://veh47.github.io/2019/09/dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
<meta property="og:site_name" content="Eleven">
<meta property="og:description" content="Docker通过读取Dockerfile中的指令自动构建镜像，一个文本文件包含构建镜像的所有指令。Dockerfile遵循特定的格式和指令集，您可以在Dockerfile中引用它们。">
<meta name="twitter:description" content="Docker通过读取Dockerfile中的指令自动构建镜像，一个文本文件包含构建镜像的所有指令。Dockerfile遵循特定的格式和指令集，您可以在Dockerfile中引用它们。">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2019-09-28T17:00:55">
  
  
    <meta property="article:modified_time" content="2019-09-28T17:00:55">
  
  
  
    
      <meta property="article:section" content="docker">
    
  
  
    
      <meta property="article:tag" content="docker">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://veh47.github.io/images/coffice.png">
  <meta property="twitter:image" content="https://veh47.github.io/images/coffice.png">


    <title>Dockerfile最佳实践</title>

    <link rel="icon" href="https://veh47.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://veh47.github.io/2019/09/dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://veh47.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="3">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://veh47.github.io/">Eleven</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://veh47.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://veh47.github.io/images/coffice.png" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="3">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://veh47.github.io/#about">
          <img class="sidebar-profile-picture" src="https://veh47.github.io/images/coffice.png" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Eleven</h4>
        
          <h5 class="sidebar-profile-bio">When you are looking at the stars, please put the brightest star shining night sky as my soul.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/VEH47/veh47.github.io" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://veh47.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="3"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Dockerfile最佳实践
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-09-28T17:00:55&#43;08:00">
        
  九月 28, 2019

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://veh47.github.io/categories/docker">docker</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>Docker通过读取Dockerfile中的指令自动构建镜像，一个文本文件包含构建镜像的所有指令。Dockerfile遵循特定的格式和指令集，您可以在Dockerfile中引用它们。</p>

<p>Docker镜像由只读层组成，每一层代表一个Dockerfile指令集。每一层都是前一层变化的增量。考虑这个Dockerfile：</p>

<p>FROMubuntu:18.04</p>

<p>COPY . /app</p>

<p>RUN make /app</p>

<p>CMD python/app/app.py</p>

<p>每条指令创建一个层：</p>

<p>FROM 从ubuntu:18.04基础镜像创建一个层。</p>

<p>COPY 从Docker客户端当前目录中添加文件。</p>

<p>RUN 使用make构建你的应用。</p>

<p>CMD 指定容器运行时执行的命令。</p>

<p>当你运行一个镜像生成一个容器，在底层的顶部添加一个可写层（容器层）。对正在运行容器所做的所有更改，比如写文件，修改已存在的文件，和删除文件，都被写入这个可写空口层。</p>

<p>Dockerfile定义的容器应该生成尽可能短暂的容器，通过“短暂”，我们的意思是容器可以被停止或销毁，然后重建并用最小的设置和配置。从而充分利用容器的分层存储。</p>

<h3 id="1-理解构建上下文">1.理解构建上下文</h3>

<p>执行dockerbuild命令时，当前工作目录称为构建上下文。 默认情况下，假定Dockerfile位于此处，但您可以使用文件标志（-f）指定其他位置。 无论Dockerfile实际存在于何处，当前目录中的所有文件和目录的递归内容都将作为构建上下文发送到Docker守护程序。</p>

<p>构建上下文件示例：</p>

<p>创建并CD进入构建上下文目录，将“hello”写入名为hello的文本文件中，并创建一个在其上运行cat的Dockerfile。从构建上下文（.）中构建镜像。</p>

<p>mkdirmyproject &amp;&amp; cd myproject</p>

<p>echo &ldquo;hello&rdquo;&gt; hello</p>

<p>echo -e &ldquo;FROMbusyboxCOPY /hello /RUN cat /hello&rdquo; &gt; Dockerfile</p>

<p>docker build -t helloapp:v1 .</p>

<p>将Dockerfile和hello移动到单独的目录中并构建映像的第二个版本（不依赖于上一次构建的缓存）。使用-f指向Dockerfile并指定构建上下文的目录：</p>

<p>mkdir -p dockerfiles context</p>

<p>mv Dockerfile dockerfiles &amp;&amp; mv hello context</p>

<p>docker build &ndash;no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context</p>

<p>无意中包含构建不必要的文件会导致更大的构建上下文和更大的镜像，这将增加构建时间，拉取和推送镜像的时间以及容器运行时占用更多的存储空间。查看构建上下文大小，在构建Dockerfile时查找类似信息。</p>

<p>Sending buildcontext to Docker daemon  187.8MB</p>

<h3 id="2-基于stdin的构建上下文">2.基于stdin的构建上下文</h3>

<p>Docker能通过stdin与本址或远程构建上下文管道Dockerfile来构建镜像。通过stdin管道Dockerfile对于执行一次性构建非常有用，无需将Dockerfile写入磁盘，或者在生成Dockerfile的情况下，并且之后不应该持久化。</p>

<p>例如，以下命令是等效的：</p>

<p>echo -e &lsquo;FROMbusyboxRUN echo &ldquo;hello world&rdquo;&rsquo; | docker build –</p>

<p>docker build-&lt;&lt;EOF</p>

<p>FROM busybox</p>

<p>RUN echo&rdquo;hello world&rdquo;</p>

<p>EOF</p>

<p>在Dockerfile不需要将文件复制到映像中并且提高构建速度的情况下，省略构建上下文非常有用，因为没有文件发送到守护程序。</p>

<p>注意：如果使用此语法，尝试构建镜像时使用COPY或ADD的Dockerfile将失败，以下示例说明了这一点：</p>

<h4 id="create-a-directory-to-work-in">create a directory to work in</h4>

<p>mkdir example</p>

<p>cd example</p>

<h4 id="create-anexample-file">create anexample file</h4>

<p>touch somefile.txt</p>

<p>docker build t myimage:latest -&lt;&lt;EOF</p>

<p>FROM busybox</p>

<p>COPYsomefile.txt .</p>

<p>RUN cat /somefile.txt</p>

<p>EOF</p>

<h4 id="observethat-the-build-fails">observethat the build fails</h4>

<p>&hellip;</p>

<p>Step <sup>2</sup>&frasl;<sub>3</sub> :COPY somefile.txt .</p>

<p>COPY failed:stat /var/lib/docker/tmp/
docker-builder249218248/somefile.txt: no such file ordirectory</p>

<h3 id="3-使用stdin的dockerfile从本地上下文构建镜像">3.使用stdin的Dockerfile从本地上下文构建镜像</h3>

<p>使用此语法使用本地文件系统上下文构建镜像，但使用stdin中的Dockerfile。语法使用-f（–file）选项指定要使用的Dockerfile，使用连字符（-）作为文件名来指示Docker从stdin读取Dockerfile</p>

<p>docker build[OPTIONS] -f- PATH</p>

<p>下面的示例使用当前目录（.）作为构建上下文，并使用stdin作为Dockerfile构建镜像。</p>

<h5 id="create-adirectory-to-work-in">create adirectory to work in</h5>

<p>mkdir example</p>

<p>cd example</p>

<h5 id="create-anexample-file-1">create anexample file</h5>

<p>touchsomefile.txt</p>

<p>#### build animage using the current directory as context, and a Dockerfile passed throughstdin
docker build-t myimage:latest -f- . &lt;&lt;EOF
FROM busybox</p>

<p>COPYsomefile.txt .</p>

<p>RUN cat/somefile.txt</p>

<p>EOF</p>

<h3 id="4-使用stdin的dockerfile从远程上下文构建镜像">4.使用stdin的Dockerfile从远程上下文构建镜像</h3>

<p>使用此语法使用远程git仓库上下文构建镜像，但使用stdin中的Dockerfile。语法使用-f（–file）选项指定要使用的Dockerfile，使用连字符（-）作为文件名来指示Docker从stdin读取Dockerfile。</p>

<p>docker build[OPTIONS] -f- PATH</p>

<p>如果您希望从仓库构建映像不包含Dockerfile，或者您希望使用自定义Dockerfile构建，而不维护自己的仓库分支，则此语法非常有用。</p>

<p>下面的示例使用stdin中的Dockerfile构建映像，并在GitHub上的“hello-world”Git仓库中添加README.md文件。</p>

<p>docker build -t myimage:latest -f- <a href="https://github.com/docker-library/hello-world.git">https://github.com/docker-library/hello-world.git</a>&lt;&lt;EOF</p>

<p>FROM busybox</p>

<p>COPYREADME.md .</p>

<p>EOF</p>

<p>使用远程Git存储库构建镜像作为构建上下文时，Docker会在本地计算机上执行仓库的git克隆，并将这些文件作为构建上下文发送到守护程序。 此功能要求在运行dockerbuild命令的主机上安装git。</p>

<h3 id="5-通过-dockerignore排除文件">5.通过.dockerignore排除文件</h3>

<p>要排除与构建无关的文件（不重构源仓库），请使用.dockerignore文件。 此文件支持类似于.gitignore文件的排除模式。有关创建的信息，请参阅.dockerignore文件。</p>

<h3 id="6-使用多阶段构建">6.使用多阶段构建</h3>

<p>多阶段构建允许您大幅减小最终镜像的大小，而无需减少中间层和文件的数量。</p>

<p>由于镜像是在构建过程的最后阶段构建的，因此可以通过利用构建缓存来最小化镜像层。</p>

<p>例如，如果您的构建包含多个层，则可以从较不频繁更改（以确保构建缓存可重用）到更频繁更改的顺序进行排序：</p>

<p>安装构建应用程序所需的工具</p>

<p>安装或更新库依赖项</p>

<p>生成您的应用程序</p>

<p>Go应用程序的Dockerfile如下所示：</p>

<p>FROM golang:1.11-alpine AS build</p>

<h5 id="installtools-required-for-project">Installtools required for project</h5>

<p>Run <code>dockerbuild --no-cache .</code> to update dependencies</p>

<p>RUN apk add &ndash;no-cache git</p>

<p>RUN go get github.com/golang/dep/cmd/dep</p>

<h5 id="listproject-dependencies-with-gopkg-toml-and-gopkg-lock">Listproject dependencies with Gopkg.toml and Gopkg.lock</h5>

<h4 id="theselayers-are-only-re-built-when-gopkg-files-are-updated">Theselayers are only re-built when Gopkg files are updated</h4>

<p>COPY Gopkg.lock Gopkg.toml /go/src/project/</p>

<p>WORKDIR /go/src/project/</p>

<h4 id="installlibrary-dependencies">Installlibrary dependencies</h4>

<p>RUN depensure -vendor-only</p>

<p>Copy theentire project and build it</p>

<h4 id="this-layeris-rebuilt-when-a-file-changes-in-the-project-directory">This layeris rebuilt when a file changes in the project directory</h4>

<p>COPY ./go/src/project/</p>

<p>RUN go build -o /bin/project</p>

<p>#### Thisresults in a single layer image</p>

<p>FROM scratch</p>

<p>COPY&ndash;from=build /bin/project /bin/project</p>

<p>ENTRYPOINT[&ldquo;/bin/project&rdquo;]</p>

<p>CMD[&ldquo;&ndash;help&rdquo;]</p>

<p>不要安装不必要的包</p>

<p>为了降低复杂性，依赖性，文件大小和构建时间，请避免安装额外的或不必要的软件包，即便它们可能“很好”。例如，您不需要在数据库映像中包含文本编辑器。</p>

<h3 id="7-解耦应用程序">7.解耦应用程序</h3>

<p>每个容器应该只有一个关系。 将应用程序分离到多个容器中可以更容易地水平扩展和重用容器。例如，Web应用程序堆栈可能包含三个独立的容器，每个容器都有自己独特的映像，以分离的方式管理Web应用程序，数据库和缓存。</p>

<p>将每个容器限制为一个进程是一个很好的经验法则，但它不是一个硬性规则。例如，不仅可以使用init进程生成容器，而且某些程序可能会自行生成其他进程。 例如，Celery可以生成多个工作进程，Apache可以为每个请求创建一个进程。</p>

<p>使用您的最佳判断，尽可能保持容器清洁和模块化。如果容器彼此依赖，则可以使用Docker容器网络来确保这些容器可以进行通信。</p>

<h3 id="8-最小化层数">8.最小化层数</h3>

<p>在老版本的Docker中，最大限度地减少镜像中的层数以确保它们具有更高的性能。 添加了以下特性以减少此限制：</p>

<p>只有RUN，COPY，ADD指令才能创建图层。 其他指令创建临时中间层，并不增加构建的大小。</p>

<p>尽可能的，使用多阶段构建，并仅将所需的复制到最终镜像中。 这允许您在中间构建阶段中包含工具和调试信息，而不会增加最终图像的大小。</p>

<p>对多行参数进行排序</p>

<p>尽可能的，通过按字母顺序排序多行参数来缓解以后的更改。这有助于避免重复包并使更容易更新。这也使PR更容易阅读和审查。在反斜杠（）之前添加空格也有帮助。</p>

<p>这是一个编译包依赖示例：</p>

<p>RUN apt-getupdate &amp;&amp; apt-get install -y</p>

<p>bzr</p>

<p>cvs</p>

<p>git</p>

<p>mercurial</p>

<p>subversion</p>

<h3 id="10-利用构建缓存">10.利用构建缓存</h3>

<p>构建映像时，Docker会逐步执行Dockerfile中的指令，按指定的顺序执行每个指令。在检查每条指令时，Docker会在其缓存中查找可以重用的现有映像，而不是创建新的（重复）映像。</p>

<p>如果您根本不想使用缓存，可以在docker build命令中使用–no-cache=true选项。但是，如果您确实让Docker使用其缓存，那么了解它何时可以找到匹配的镜像层非常重要。 Docker遵循的基本规则概述如下：</p>

<p>从已经在高速缓存中的镜像开始，下一条指令将从基础镜像导出的所有子镜像层进行比较，以查看它们中的一个是否使用完全相同的指令构建。如果不是，则缓存无效。</p>

<p>在大多数情况下，只需将Dockerfile中的指令与其中一个子镜像层进行比较即可。 但是，某些指令需要更多的检查和解析。</p>

<p>对于ADD和COPY指令，将检查镜像中文件的内容，并为每个文件计算校验和。在这些校验和中不考虑文件的最后修改时间和最后访问时间。在缓存查找期间，将校验和与现有映像中的校验和进行比较。如果文件中的任何内容（例如内容和元数据）发生了任何更改，则缓存将失效。</p>

<p>除了ADD和COPY命令之外，缓存检查不会查看容器中的文件以确缓存匹配。例如，在执行RUNapt-get -y update命令时，不检查容器中更新的文件以确定是否存在缓存命中。在这种情况下，只需使用命令字符串本身来查找匹配项。</p>

<p>缓存无效后，所有后续Dockerfile命令都会生成新镜像，并且不使用缓存。</p>

<h3 id="11-dockerfile指令">11.Dockerfile指令</h3>

<p>这些建议旨在帮助您创建高效且可维护的Dockerfile。</p>

<h3 id="12-from">12.FROM</h3>

<p>尽可能使用当前的官方镜像作为镜像的基础。我们推荐Alpine镜像，因为它是严格控制的并且尺寸小（目前小于5 MB），同时仍然是完整的Linux发行版。</p>

<h3 id="13-label">13.LABEL</h3>

<p>您可以为镜像添加标签，以帮助按项目组织镜像，记录许可信息，辅助自动化或其他原因。对于每个标签，添加以LABEL开头并带有一个或多个键值对。以下示例显示了不同的可接受格式。内容包括解释性意见。</p>

<p>必须引用带空格的字符串或必须转义空格。 内引号字符（“）也必须转义。</p>

<h5 id="设置一个或多个单独的标签">设置一个或多个单独的标签</h5>

<p>LABELcom.example.version=&ldquo;0.0.1-beta&rdquo;</p>

<p>LABELvendor1=&ldquo;ACME Incorporated&rdquo;</p>

<p>LABELvendor2=ZENITH Incorporated</p>

<p>LABELcom.example.release-date=&ldquo;2015-02-12&rdquo;</p>

<p>LABELcom.example.version.is-production=&ldquo;&rdquo;</p>

<p>镜像可以有多个标签。在Docker 1.10之前，建议将所有标签组合到单个LABEL指令中以防止创建额外的层。这不再是必需的，但仍然支持组合标签。</p>

<h5 id="在一行设置多个标签">在一行设置多个标签</h5>

<p>LABEL com.example.version=&ldquo;0.0.1-beta&rdquo;com.example.release-date=&ldquo;2015-02-12&rdquo;</p>

<p>以上也可以写成：</p>

<h5 id="一次设置多个标签-使用行连续符进行换行">一次设置多个标签，使用行连续符进行换行</h5>

<p>LABELvendor=ACME Incorporated</p>

<p>com.example.is-beta=</p>

<p>com.example.is-production=&ldquo;&rdquo;</p>

<p>com.example.version=&ldquo;0.0.1-beta&rdquo;</p>

<p>com.example.release-date=&ldquo;2015-02-12&rdquo;</p>

<h3 id="14-run">14.RUN</h3>

<p>在使用反斜杠分隔的多行拆分长或复杂的RUN语句，以使Dockerfile更具可读性，可理解性和可维护性。</p>

<p>APT-GET</p>

<p>RUN最常见的用例可能是apt-get安装软件包，所以RUN apt-get命令有几个需要注意的问题。</p>

<p>避免RUNapt-get update和dist-upgrade，因为父映像中的许多“基本”包无法在非特权容器内升级。如果镜像中包含的包已过期，请与其维护人员联系。如果你知道有一个需要更新的特定包foo，请使用apt-get install -y foo自动更新。</p>

<p>始终将RUNapt-get update与apt-get install结合在同一个RUN语句中。例如：</p>

<p>RUN apt-get update &amp;&amp; apt-get install -y</p>

<p>package-bar</p>

<p>package-baz</p>

<p>package-foo</p>

<p>在RUN语句中单独使用apt-get update会导致缓存问题和后续的apt-get install失败。例如，假设你有一个Dockerfile：</p>

<p>以上也可以写成：</p>

<h5 id="fromubuntu-18-04">FROMubuntu:18.04</h5>

<p>RUN apt-getupdate
RUN apt-getinstall -y curl
构建映像后，所有层都在Docker缓存中。假设您稍后通过apt-get install添加额外的包来修改：</p>

<h5 id="fromubuntu-18-04-1">FROMubuntu:18.04</h5>

<p>RUN apt-get update</p>

<p>RUN apt-getinstall -y curl nginx</p>

<p>Docker将初始和修改的指令视为相同，并重用前面步骤中的缓存。因此，不会执行apt-get update，因为构建使用缓存版本。由于apt-get update未运行，因此您的构建可能会获得curl和nginx软件包的旧版本。</p>

<p>使用RUNapt-get update &amp;&amp; apt-get install -y可确保您的Dockerfile安装最新的软件包版本，无需进一步编码或手动干预。这种技术被称为“缓存破坏”。您还可以通过指定包版本来实现缓存清除。这称为版本固定，例如：</p>

<p>RUN apt-getupdate &amp;&amp; apt-get install -y</p>

<p>package-bar</p>

<p>package-baz</p>

<p>package-foo=1.3.*</p>

<p>版本固定强制构建以检索特定版本，而不管缓存中的内容是什么。此技术还可以减少由于所需包中意外更改而导致的故障。</p>

<p>如下是一个结构良好的RUN指令，它演示了所有apt-get建议。</p>

<p>RUN apt-getupdate &amp;&amp; apt-get install -y</p>

<p>aufs-tools</p>

<p>automake</p>

<p>build-essential</p>

<p>curl</p>

<p>dpkg-sig</p>

<p>libcap-dev</p>

<p>libsqlite3-dev</p>

<p>mercurial</p>

<p>reprepro</p>

<p>ruby1.9.1</p>

<p>ruby1.9.1-dev</p>

<p>s3cmd=1.1.*</p>

<p>&amp;&amp; rm -rf /var/lib/apt/lists/*</p>

<p>s3cmd参数指定版本1.1*。如果镜像使用以前的旧版本，则指定新版本会导致apt-get update缓存失效，并确保安装新版本。列出每行的包也可以防止包重复中的错误。</p>

<p>此外，当您通过删除/var/lib/apt/lists/清理apt缓存时，它会减小映像大小，因为apt缓存不存储在层中。 由于RUN语句以apt-get update开头，因此在apt-get install之前始终刷新包缓存。</p>

<p>官方Debian和Ubuntu映像自动运行apt-get clean，因此不需要显式调用。</p>

<p>USING PIPES
某些RUN命令依赖于使用管道符（|）将一个命令的输出传递到另一个命令的能力，如下例所示：</p>

<p>RUN wget –O –<a href="https://some.site">https://some.site</a> | wc –l&gt; /number</p>

<p>Docker使用/bin/sh -c解释器执行这些命令，该解释器仅评估管道中最后一个操作的退出代码以确定成功。在上面的示例中，只要wc -l命令成功，即使wget命令失败，此构建步骤也会成功并生成新映像。</p>

<p>如果希望命令由于管道中任何阶段的错误而失败，请在之前添加set -o pipefail &amp;&amp;，以确保意外错误可防止构建无意义的镜像。例如：</p>

<p>RUN set -opipefail &amp;&amp; wget -O - <a href="https://some.site">https://some.site</a> | wc -l &gt; /number</p>

<p>并不是所有shell都支持 –o pipefail</p>

<p>在基于Debian的映像上的dash shell的情况下，请考虑使用RUN的时候明确选择支持pipefail选项的shell。 例如：</p>

<p>RUN [&ldquo;/bin/bash&rdquo;,&ldquo;-c&rdquo;, &ldquo;set -o pipefail &amp;&amp; wget -O - <a href="https://some.site">https://some.site</a> |wc -l &gt; /number&rdquo;]</p>

<p>CMD</p>

<p>CMD指令应该用于运行镜像包含的软件以及任何参数。CMD应该几乎总是以CMD [“executable”，“param1”，“param2”……]的形式使用。因此，如果镜像用于服务，例如Apache和Rails，则可以运行类似CMD[“apache2”，“ –  DFOREGROUND”]的内容。实际上，建议将这种形式的指令用于任何基于服务的镜像。</p>

<p>在大多数其他情况下，CMD应该被赋予一个交互式shell，例如bash，python和perl。例如，CMD [“perl”，“ – de0”]，CMD [“python”]或CMD [“php”，“ – a”]。使用这个表单意味着当你执行像docker run -it python这样的东西时，你将被放入一个可用的shell中，准备就绪。 CMD应该很少以CMD [“param”，“param”]的方式与ENTRYPOINT一起使用，除非您和您的预期用户已经非常熟悉ENTRYPOINT的工作原理。</p>

<p>EXPOSE</p>

<p>EXPOSE指令指示容器侦听连接的端口。因此，您应该为您的应用程序使用通用的传统端口。 例如，包含Apache Web服务器的映像将使用EXPOSE 80，而包含MongoDB的映像将使用EXPOSE 27017等。</p>

<p>对于外部访问，您可以执行docker run，该标志指示如何将指定端口映射到他们选择的端口。对于容器链接，Docker为从接收容器返回源的路径提供环境变量（即MYSQL_PORT_3306_TCP）。</p>

<p>ENV</p>

<p>为了使新软件更易于运行，您可以使用ENV更新容器安装的软件的PATH环境变量。 例如，ENV PATH/usr/local/nginx/bin:$PATH确保CMD [“nginx”]正常运行。</p>

<p>ENV指令对于提供特定于您希望容纳的服务的必需环境变量也很有用，例如Postgres’s的PGDATA。</p>

<p>最后，ENV还可用于设置常用版本号，以便更容易维护版本，如以下示例所示：</p>

<p>ENV PG_MAJOR9.3</p>

<p>ENV PG_VERSION 9.3.4</p>

<p>RUN curl -SLhttp://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress&amp;&amp; …</p>

<p>ENV PATH/usr/local/postgres-$PG_MAJOR/bin:$PATH</p>

<p>类似于在程序中使用常量变量（解耦硬编码），此方法允许您更改单个ENV指令以自动神奇地破坏容器中的软件版本。</p>

<p>每条ENV都会创建一个新的中间层，就像RUN命令一样。这意味着即使您在将来的镜像中取消设置环境变量，它仍然会在此镜像层中保留，并且其值可以导出。您可以通过创建如下所示的Dockerfile来测试它，然后构建它。</p>

<p>FROM alpineENV ADMIN_USER=&ldquo;mark&rdquo;</p>

<p>RUN echo$ADMIN_USER &gt; ./mark</p>

<p>RUN unsetADMIN_USER $ docker run&ndash;rm test sh -c &lsquo;echo $ADMIN_USER&rsquo;</p>

<p>mark</p>

<p>要防止这种情况，并且实际上取消环境变量，请使用带有RUN命令执行shell执行 set和unset变量。您可以使用; 或＆＆分隔命令。如果您使用第二种方法，并且其中一个命令失败，则docker构建也会失败。这通常是一个好办法。使用作为Linux Dockerfiles的行连续符可以提高可读性。 您还可以将所有命令放入shell脚本中，并使用RUN命令运行该shell脚本。</p>

<p>FROM alpine</p>

<p>RUN export ADMIN_USER=&ldquo;mark&rdquo;</p>

<p>&amp;&amp; echo $ADMIN_USER &gt; ./mark</p>

<p>&amp;&amp; unset ADMIN_USER</p>

<p>CMD sh</p>

<p>$ docker run&ndash;rm test sh -c &lsquo;echo $ADMIN_USER&rsquo;</p>

<p>ADDor COPY</p>

<p>尽管ADD和COPY在功能上相似，但一般来说，COPY是优选的。那是因为它比ADD更透明。COPY仅支持将本地文件复制到容器中，而ADD具有一些功能（如本地的tar提取和远程URL支持），这些功能并不是很明显。 因此，ADD的最佳用途是将本地tar文件自动提取到镜像中，如ADD rootfs.tar.xz /所示。</p>

<p>如果您有多个使用上下文中不同文件的Dockerfile步骤，请单独复制它们，而不是一次复制它们。 这可确保每个步骤的构建缓存仅在特定所需文件更改时失效（强制重新执行该步骤）。例如：</p>

<p>COPY requirements.txt /tmp/</p>

<p>RUN pipinstall &ndash;requirement /tmp/requirements.txt</p>

<p>COPY . /tmp/</p>

<p>由于镜像大小很重要，因此强烈建议不要使用ADD从远程URL获取包。你应该使用curl或wget代替。这样，您可以删除提取后不再需要的文件，也不必在图像中添加其他镜像层。 例如，你应该避免做以下事情：</p>

<p>ADD <a href="http://example.com/big.tar.xz">http://example.com/big.tar.xz</a> /usr/src/things</p>

<p>/RUN tar -xJf/usr/src/things/big.tar.xz -C /usr/src/things</p>

<p>RUN make -C/usr/src/things all</p>

<p>最佳做法：</p>

<p>RUN mkdir -p/usr/src/things &amp;&amp; curl -SLhttp://example.com/big.tar.xz  | tar-xJC /usr/src/things   &amp;&amp; make -C /usr/src/things all</p>

<p>对于不需要ADD的tar自动提取功能的其他项目（文件，目录），应始终使用COPY。</p>

<p>ENTRYPOINT</p>

<p>ENTRYPOINT的最佳用途是设置图像的主程序，允许该镜像执行命令一样运行（然后使用CMD作为默认标志）。</p>

<p>让我们从命令行工具s3cmd的镜像示例开始：</p>

<p>ENTRYPOINT[&ldquo;s3cmd&rdquo;]</p>

<p>CMD[&ldquo;&ndash;help&rdquo;]
现在可以像这样运行镜像来显示命令的帮助：</p>

<p>$ docker runs3cmd</p>

<p>或使用正确的参数执行命令：</p>

<p>$ docker runs3cmd ls s3://mybucket</p>

<p>这个很有用，因为镜像名称可以兼作二进制文件的引用，如上面的命令所示。</p>

<p>ENTRYPOINT指令也可以与辅助脚本结合使用，使其能够以与上述命令类似的方式运行，即使启动该工具可能需要多个步骤。</p>

<p>例如，Postgres官方镜像使用以下脚本作为其ENTRYPOINT：</p>

<p>#!/bin/bash</p>

<p>set -e</p>

<p>if [&ldquo;$1&rdquo; = &lsquo;postgres&rsquo; ]; then</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></pre></td>
<td class="lntd">
<pre class="chroma">chown -R postgres &#34;$PGDATA&#34;

if [ -z &#34;$(ls -A&#34;$PGDATA&#34;)&#34; ]; then 

   gosu postgres initdb  

fi    

exec gosu postgres &#34;$@&#34;</pre></td></tr></table>
</div>
</div>
<p>fi</p>

<p>exec&rdquo;$@&rdquo;</p>

<p>配置应用进程PID为1</p>

<p>此脚本使用exec Bash命令，以便最终运行的应用程序成为容器的PID 1.这允许应用程序接收发送到容器的任何Unix信号。</p>

<p>帮助程序脚本被复制到容器中并通过容器启动时的ENTRYPOINT运行：</p>

<p>COPY./docker-entrypoint.sh /</p>

<p>ENTRYPOINT[&ldquo;/docker-entrypoint.sh&rdquo;]</p>

<p>CMD[&ldquo;postgres&rdquo;]</p>

<p>该脚本允许用户以多种方式与Postgres交互。它可以简单地启动Postgres：</p>

<p>$ docker runpostgres</p>

<p>或者，它可用于运行Postgres并将参数传递给服务器：</p>

<p>$ docker runpostgres postgres &ndash;help</p>

<p>最后，它还可以用来启动一个完全不同的工具，比如Bash：</p>

<p>$ docker run –rm–it postgres bash</p>

<p>VOLUME</p>

<p>VOLUME指令用于挂载由docker容器创建的任何数据库存储区域，配置存储或文件/文件夹。强烈建议您将VOLUME用于镜像的任何可变或用户可维护部分。</p>

<p>USER</p>

<p>如果服务可以在没有权限的情况下运行，请使用USER更改为非root用户。首先在Dockerfile中创建用户和组，例如RUN groupadd -r postgres &amp;&amp; useradd –no-log-init -r -gpostgres postgres。</p>

<p>考虑一个显式的UID/GID</p>

<p>镜像中的用户和组被分配了非确定性UID/GID，因为无论镜像如何重建，都会分配“下一个”UID/GID。 因此，如果它很重要，您应该分配一个显式的UID/GID。</p>

<p>避免安装或使用sudo，因为它具有不可预测的TTY和可能导致问题的信号转发行为。如果您绝对需要与sudo类似的功能，例如将守护程序初始化为root但将其作为非root运行，请考虑使用“gosu”。</p>

<p>最后，为了减少层数和复杂性，请避免频繁地来回切换USER。</p>

<p>WORKDIR</p>

<p>为了清晰和可靠，您应该始终使用WORKDIR的绝对路径。 此外，您应该使用WORKDIR而不是像这样激进指令RUN CD …… &amp;&amp; do-something，这些指令难以阅读，故障排除和维护。</p>

<p>ONBUILD</p>

<p>在当前Dockerfile构建完成后执行ONBUILD命令。 ONBUILD在从当前镜像派生的任何子镜像中执行。将ONBUILD命令视为父Dockerfile为子Dockerfile提供的指令。</p>

<p>Docker构建在子Dockerfile中的任何命令之前执行ONBUILD命令。</p>

<p>ONBUILD对于将从给定镜像构建的镜像非常有用。例如，您可以使用ONBUILD作为语言堆栈映像，在Dockerfile中构建使用该语言编写的任意用户软件。</p>

<p>从ONBUILD构建的镜像应该获得一个单独的标记，例如：ruby：1.9-onbuild或ruby：2.0-onbuild。</p>

<p>将ADD或COPY放入ONBUILD时要小心。如果新构建的上下文缺少要添加的资源，则“onbuild”镜像将发生灾难性故障。如上所述，添加单独的标记有助于通过Dockerfile作者做出选择来缓解这种情况。</p>

<h3 id="15-官方镜像的例子">15.官方镜像的例子</h3>

<p>这些官方图像具有示例性Dockerfile：</p>

<p>Go      <a href="https://hub.docker.com/_/golang/">https://hub.docker.com/_/golang/</a></p>

<p>Perl    <a href="https://hub.docker.com/_/perl/">https://hub.docker.com/_/perl/</a></p>

<p>Hy      <a href="https://hub.docker.com/_/hylang/">https://hub.docker.com/_/hylang/</a></p>

<p>Ruby  <a href="https://hub.docker.com/_/ruby/">https://hub.docker.com/_/ruby/</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://veh47.github.io/tags/docker/">docker</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://veh47.github.io/2019/09/redis-keepalive/" data-tooltip="Redis&#43;keepalive">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 Eleven. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://veh47.github.io/2019/09/redis-keepalive/" data-tooltip="Redis&#43;keepalive">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="3">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://veh47.github.io/images/coffice.png" alt="作者的图片" />
    
    <h4 id="about-card-name">Eleven</h4>
    
      <div id="about-card-bio">When you are looking at the stars, please put the brightest star shining night sky as my soul.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        SRE
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        BeiJing
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://veh47.github.io/images/cover-v1.2.0.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://veh47.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

